<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/Assets/Scripts/FloorGenerator.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/FloorGenerator.cs" />
              <option name="originalContent" value="using UnityEngine;&#10;&#10;public class FloorGenerator : MonoBehaviour&#10;{&#10;    public event System.Action&lt;float, float, float, float&gt; OnFloorGenerated;&#10;    public event System.Action&lt;Vector3&gt; OnPlatformGenerated;&#10;    public GameObject[] floorPrefabs;&#10;    public GameObject platformPrefab;&#10;    public int worldSize = 2;&#10;    private float _spacing = 4f;&#10;    private static bool timerStarted = false; // Pour éviter les démarrages multiples&#10;&#10;    void Start()&#10;    {&#10;        GameObject prefab = floorPrefabs[Random.Range(0, floorPrefabs.Length)];&#10;        _spacing = prefab.GetComponentInChildren&lt;RefPointFloor&gt;().getDistance() * 2;&#10;&#10;        // S'abonner à l'événement pour générer la plateforme après le sol&#10;        OnFloorGenerated += GeneratePlatformAfterFloor;&#10;&#10;        GenerateFloor();&#10;    }&#10;&#10;    void GenerateFloor()&#10;    {&#10;        for (int x = 0; x &lt; worldSize; x++)&#10;        {&#10;            for (int z = 0; z &lt; worldSize; z++)&#10;            {&#10;                Vector3 position = new Vector3(x * _spacing, 0, z * _spacing);&#10;                GameObject prefab = floorPrefabs[Random.Range(0, floorPrefabs.Length)];&#10;                GameObject floorInstance = Instantiate(prefab, position, Quaternion.identity);&#10;                &#10;                // Utiliser les colliders existants au lieu d'en ajouter de nouveaux&#10;                Collider[] existingColliders = floorInstance.GetComponentsInChildren&lt;Collider&gt;();&#10;                &#10;                if (existingColliders.Length &gt; 0)&#10;                {&#10;                    // Dupliquer le premier collider trouvé pour en faire un trigger&#10;                    Collider originalCollider = existingColliders[0];&#10;                    &#10;                    // Créer un GameObject enfant pour le trigger&#10;                    GameObject triggerObject = new GameObject(&quot;FloorTrigger&quot;);&#10;                    triggerObject.transform.SetParent(floorInstance.transform);&#10;                    triggerObject.transform.localPosition = Vector3.zero;&#10;                    &#10;                    // Copier le collider et le configurer comme trigger&#10;                    BoxCollider triggerCollider = triggerObject.AddComponent&lt;BoxCollider&gt;();&#10;                    triggerCollider.isTrigger = true;&#10;                    triggerCollider.size = new Vector3(_spacing, 2f, _spacing);&#10;                    &#10;                    // Ajouter le handler de trigger sur l'objet trigger&#10;                    FloorTriggerHandler triggerHandler = triggerObject.AddComponent&lt;FloorTriggerHandler&gt;();&#10;                    triggerHandler.floorGenerator = this;&#10;                }&#10;                else&#10;                {&#10;                    // Fallback si aucun collider n'existe&#10;                    BoxCollider triggerCollider = floorInstance.AddComponent&lt;BoxCollider&gt;();&#10;                    triggerCollider.isTrigger = true;&#10;                    triggerCollider.size = new Vector3(_spacing, 2f, _spacing);&#10;                    &#10;                    FloorTriggerHandler triggerHandler = floorInstance.AddComponent&lt;FloorTriggerHandler&gt;();&#10;                    triggerHandler.floorGenerator = this;&#10;                }&#10;            }&#10;        }&#10;&#10;        var minX = -_spacing / 2;&#10;        var minZ = -_spacing / 2;&#10;        var maxX = worldSize * _spacing - _spacing / 2;&#10;        var maxZ = worldSize * _spacing - _spacing / 2;&#10;        OnFloorGenerated?.Invoke(minX, minZ, maxX, maxZ);&#10;    }&#10;    &#10;    public void OnPlayerEnterFloor()&#10;    {&#10;        if (!timerStarted)&#10;        {&#10;            timerStarted = true;&#10;            Timer timer = FindObjectOfType&lt;Timer&gt;();&#10;            if (timer != null)&#10;            {&#10;                timer.StartTimer();&#10;                Debug.Log(&quot;Joueur entré sur le floor - Timer démarré !&quot;);&#10;            }&#10;        }&#10;    }&#10;&#10;    void GeneratePlatformAfterFloor(float minX, float minZ, float maxX, float maxZ)&#10;    {&#10;        // Vérifier qu'un prefab de plateforme est assigné&#10;        if (platformPrefab == null)&#10;        {&#10;            Debug.LogWarning(&quot;Aucun prefab de plateforme assigné !&quot;);&#10;            return;&#10;        }&#10;&#10;        // Placer la plateforme juste à côté du bord nord du terrain&#10;        float centerX = (minX + maxX) / 2f;&#10;        Vector3 platformPosition = new Vector3(centerX, 0, maxZ + _spacing);&#10;&#10;        Instantiate(platformPrefab, platformPosition, Quaternion.identity);&#10;        &#10;        // Notifier que la plateforme a été générée avec sa position&#10;        OnPlatformGenerated?.Invoke(platformPosition);&#10;    }&#10;&#10;    // Classe interne simple pour gérer les triggers&#10;    public class FloorTriggerHandler : MonoBehaviour&#10;    {&#10;        public FloorGenerator floorGenerator;&#10;        &#10;        void OnTriggerEnter(Collider other)&#10;        {&#10;            if (other.CompareTag(&quot;Player&quot;))&#10;            {&#10;                floorGenerator.OnPlayerEnterFloor();&#10;            }&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="using UnityEngine;&#10;&#10;public class FloorGenerator : MonoBehaviour&#10;{&#10;    public event System.Action&lt;float, float, float, float&gt; OnFloorGenerated;&#10;    public event System.Action&lt;Vector3&gt; OnPlatformGenerated; // Nouvel événement pour la position de la plateforme&#10;    public GameObject[] floorPrefabs;&#10;    public GameObject platformPrefab; // Prefab spécifique pour la plateforme, assignable depuis Unity&#10;    public int worldSize = 2;&#10;    private float _spacing = 4f;&#10;&#10;    void Start()&#10;    {&#10;        GameObject prefab = floorPrefabs[Random.Range(0, floorPrefabs.Length)];&#10;        _spacing = prefab.GetComponentInChildren&lt;RefPointFloor&gt;().getDistance() * 2;&#10;&#10;        // S'abonner à l'événement pour générer la plateforme après le sol&#10;        OnFloorGenerated += GeneratePlatformAfterFloor;&#10;&#10;        GenerateFloor();&#10;    }&#10;&#10;    void GenerateFloor()&#10;    {&#10;        for (int x = 0; x &lt; worldSize; x++)&#10;        {&#10;            for (int z = 0; z &lt; worldSize; z++)&#10;            {&#10;                Vector3 position = new Vector3(x * _spacing, 0, z * _spacing);&#10;                GameObject prefab = floorPrefabs[Random.Range(0, floorPrefabs.Length)];&#10;                GameObject floorInstance = Instantiate(prefab, position, Quaternion.identity);&#10;            }&#10;        }&#10;&#10;        var minX = -_spacing / 2;&#10;        var minZ = -_spacing / 2;&#10;        var maxX = worldSize * _spacing - _spacing / 2;&#10;        var maxZ = worldSize * _spacing - _spacing / 2;&#10;        OnFloorGenerated?.Invoke(minX, minZ, maxX, maxZ);&#10;    }&#10;&#10;    void GeneratePlatformAfterFloor(float minX, float minZ, float maxX, float maxZ)&#10;    {&#10;        // Vérifier qu'un prefab de plateforme est assigné&#10;        if (platformPrefab == null)&#10;        {&#10;            Debug.LogWarning(&quot;Aucun prefab de plateforme assigné !&quot;);&#10;            return;&#10;        }&#10;&#10;        // Placer la plateforme juste à côté du bord nord du terrain&#10;        float centerX = (minX + maxX) / 2f;&#10;        Vector3 platformPosition = new Vector3(centerX, 0, maxZ + _spacing);&#10;&#10;        Instantiate(platformPrefab, platformPosition, Quaternion.identity);&#10;        &#10;        // Notifier que la plateforme a été générée avec sa position&#10;        OnPlatformGenerated?.Invoke(platformPosition);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/FloorTrigger.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/FloorTrigger.cs" />
              <option name="updatedContent" value="using UnityEngine;&#10;&#10;public class FloorTrigger : MonoBehaviour&#10;{&#10;    private static bool timerStarted = false; // Static pour éviter les démarrages multiples&#10;    &#10;    void OnTriggerEnter(Collider other)&#10;    {&#10;        // Vérifier si c'est le joueur qui entre sur le floor&#10;        if (other.CompareTag(&quot;Player&quot;) &amp;&amp; !timerStarted)&#10;        {&#10;            timerStarted = true;&#10;            &#10;            // Trouver le Timer et le démarrer&#10;            Timer timer = FindObjectOfType&lt;Timer&gt;();&#10;            if (timer != null)&#10;            {&#10;                timer.StartTimer();&#10;                Debug.Log(&quot;Joueur entré sur le floor - Timer démarré !&quot;);&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/PlayerController.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/PlayerController.cs" />
              <option name="originalContent" value="using System.Collections;&#10;using System.Collections.Generic;&#10;using UnityEngine;&#10;using UnityEngine.InputSystem;&#10;&#10;public class PlayerController : MonoBehaviour&#10;{&#10;    public float moveSpeed = 5f;&#10;    public float jumpForce = 5f;&#10;&#10;    private Vector2 moveInput;&#10;    private Rigidbody rb;&#10;    private PlayerMove controls;&#10;    private bool isGrounded = true;&#10;    private bool isJumping = false;&#10;    private bool isJumpMiddle = false;&#10;    private bool isFalling = false;&#10;    private Animator animator;&#10;    private FloorGenerator floorGenerator; // Référence au FloorGenerator&#10;&#10;    void Awake()&#10;    {&#10;        controls = new PlayerMove();&#10;        &#10;        // Trouver le FloorGenerator dans la scène&#10;        floorGenerator = FindObjectOfType&lt;FloorGenerator&gt;();&#10;        if (floorGenerator != null)&#10;        {&#10;            floorGenerator.OnPlatformGenerated += PositionPlayerOnPlatform;&#10;        }&#10;    }&#10;&#10;    void OnEnable()&#10;    {&#10;        controls.Enable();&#10;        controls.Player.Move.performed += OnMovePerformed;&#10;        controls.Player.Move.canceled += OnMoveCanceled;&#10;        controls.Player.Jump.performed += OnJumpPerformed;&#10;    }&#10;&#10;    void OnDisable()&#10;    {&#10;        controls.Player.Move.performed -= OnMovePerformed;&#10;        controls.Player.Move.canceled -= OnMoveCanceled;&#10;        controls.Player.Jump.performed -= OnJumpPerformed;&#10;        controls.Disable();&#10;    }&#10;&#10;    private void OnMovePerformed(InputAction.CallbackContext ctx)&#10;    {&#10;        moveInput = ctx.ReadValue&lt;Vector2&gt;();&#10;    }&#10;&#10;    private void OnMoveCanceled(InputAction.CallbackContext ctx)&#10;    {&#10;        moveInput = Vector2.zero;&#10;    }&#10;&#10;    private void OnJumpPerformed(InputAction.CallbackContext ctx)&#10;    {&#10;        Jump();&#10;    }&#10;&#10;    // Start is called before the first frame update&#10;    void Start()&#10;    {&#10;        rb = GetComponent&lt;Rigidbody&gt;();&#10;        animator = GetComponent&lt;Animator&gt;();&#10;        &#10;        // Ne plus appeler PositionPlayerOnGround() car on attend la plateforme&#10;    }&#10;    &#10;    void PositionPlayerOnPlatform(Vector3 platformPosition)&#10;    {&#10;        // Positionner le joueur au centre de la plateforme avec un offset en Y&#10;        Vector3 playerPosition = new Vector3(platformPosition.x, platformPosition.y + 1f, platformPosition.z);&#10;        transform.position = playerPosition;&#10;        &#10;        Debug.Log($&quot;Player positioned on platform at: {playerPosition}&quot;);&#10;    }&#10;&#10;    void PositionPlayerOnGround()&#10;    {&#10;        // Cette méthode n'est plus utilisée mais gardée au cas où&#10;        // Position par défaut plus sûre au centre du monde&#10;        Vector3 defaultPosition = new Vector3(30f, 2f, 30f); // Centre du monde 30x30&#10;        &#10;        // Raycast depuis au-dessus pour trouver la surface du sol&#10;        Vector3 rayStart = defaultPosition + Vector3.up * 10f;&#10;        RaycastHit hit;&#10;        &#10;        // Raycast pour détecter tous les colliders&#10;        if (Physics.Raycast(rayStart, Vector3.down, out hit, 20f))&#10;        {&#10;            // Vérifier si c'est bien un objet au sol&#10;            if (hit.collider.gameObject.name.Contains(&quot;Ground&quot;) ||&#10;                hit.collider.gameObject.name.Contains(&quot;Floor&quot;))&#10;            {&#10;                // Place le joueur sur la surface du sol détectée avec un offset adapté au nouveau système&#10;                Vector3 newPos = hit.point + Vector3.up * 0.0f; // Pas d'offset, directement sur le NavMesh&#10;                transform.position = newPos;&#10;                Debug.Log($&quot;Player positioned on ground surface at: {newPos}&quot;);&#10;            }&#10;            else&#10;            {&#10;                // Position par défaut&#10;                transform.position = defaultPosition;&#10;                Debug.Log(&quot;Player positioned at default location&quot;);&#10;            }&#10;        }&#10;        else&#10;        {&#10;            // Position de secours&#10;            transform.position = defaultPosition;&#10;            Debug.Log(&quot;Could not find ground surface, using default position&quot;);&#10;        }&#10;    }&#10;&#10;    // Update is called once per frame&#10;    void Update()&#10;    {&#10;        // Détection de la marche via l'input&#10;        bool isWalking = moveInput.sqrMagnitude &gt; 0.01f &amp;&amp; isGrounded;&#10;&#10;        // Gestion des états de saut&#10;        isJumping = !isGrounded &amp;&amp; rb.velocity.y &gt; 0.1f;&#10;        isJumpMiddle = !isGrounded &amp;&amp; Mathf.Abs(rb.velocity.y) &lt;= 0.1f;&#10;        isFalling = !isGrounded &amp;&amp; rb.velocity.y &lt; -0.1f;&#10;&#10;        // Reset explicite si le joueur est au sol et vitesse verticale très faible&#10;        if (isGrounded &amp;&amp; Mathf.Abs(rb.velocity.y) &lt; 0.05f)&#10;        {&#10;            isJumping = false;&#10;            isJumpMiddle = false;&#10;            isFalling = false;&#10;        }&#10;&#10;        if (animator != null)&#10;        {&#10;            animator.SetBool(&quot;isWalking&quot;, isWalking);&#10;            animator.SetBool(&quot;isJumping&quot;, isJumping);&#10;            animator.SetBool(&quot;isJumpMiddle&quot;, isJumpMiddle);&#10;            animator.SetBool(&quot;isFalling&quot;, isFalling);&#10;        }&#10;    }&#10;&#10;    void FixedUpdate()&#10;    {&#10;        // Déplacement relatif à l'orientation du personnage&#10;        Vector3 direction = (transform.right * moveInput.x + transform.forward * moveInput.y).normalized;&#10;        if (direction.sqrMagnitude &gt; 0.01f)&#10;        {&#10;            rb.velocity = new Vector3(direction.x * moveSpeed, rb.velocity.y, direction.z * moveSpeed);&#10;            // Ralentit la rotation du personnage (valeur plus faible)&#10;            float rotationSpeed = 0.02f; // Valeur plus faible pour une rotation plus douce&#10;            Quaternion targetRotation = Quaternion.LookRotation(direction, Vector3.up);&#10;            rb.rotation = Quaternion.Slerp(rb.rotation, targetRotation, rotationSpeed);&#10;        }&#10;        else&#10;        {&#10;            rb.velocity = new Vector3(0, rb.velocity.y, 0);&#10;        }&#10;    }&#10;&#10;    void Jump()&#10;    {&#10;        Debug.Log($&quot;Jump input reçu | isGrounded = {isGrounded}&quot;);&#10;        if (isGrounded)&#10;        {&#10;            rb.AddForce(Vector3.up * jumpForce, ForceMode.Impulse);&#10;            isGrounded = false;&#10;        }&#10;    }&#10;&#10;    void OnCollisionEnter(Collision collision)&#10;    {&#10;        if (collision.contacts[0].normal.y &gt; 0.5f)&#10;        {&#10;            isGrounded = true;&#10;        }&#10;    }&#10;    &#10;    // Méthode pour forcer l'arrêt du joueur à la fin du jeu&#10;    public void ForceStop()&#10;    {&#10;        // Arrête tous les inputs&#10;        moveInput = Vector2.zero;&#10;        &#10;        // Arrête le mouvement du Rigidbody&#10;        if (rb != null)&#10;        {&#10;            rb.velocity = new Vector3(0, rb.velocity.y, 0); // Garde seulement la gravité&#10;        }&#10;        &#10;        // Force l'animation idle&#10;        if (animator != null)&#10;        {&#10;            animator.SetBool(&quot;isWalking&quot;, false);&#10;            animator.SetBool(&quot;isJumping&quot;, false);&#10;            animator.SetBool(&quot;isJumpMiddle&quot;, false);&#10;            animator.SetBool(&quot;isFalling&quot;, false);&#10;        }&#10;        &#10;        Debug.Log(&quot;Player movement stopped - Game Over&quot;);&#10;    }&#10;&#10;    void OnDestroy()&#10;    {&#10;        // Se désabonner de l'événement pour éviter les erreurs&#10;        if (floorGenerator != null)&#10;        {&#10;            floorGenerator.OnPlatformGenerated -= PositionPlayerOnPlatform;&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using System.Collections;&#10;using System.Collections.Generic;&#10;using UnityEngine;&#10;using UnityEngine.InputSystem;&#10;&#10;public class PlayerController : MonoBehaviour&#10;{&#10;    public float moveSpeed = 5f;&#10;    public float jumpForce = 5f;&#10;&#10;    private Vector2 moveInput;&#10;    private Rigidbody rb;&#10;    private PlayerMove controls;&#10;    private bool isGrounded = true;&#10;    private bool isJumping = false;&#10;    private bool isJumpMiddle = false;&#10;    private bool isFalling = false;&#10;    private Animator animator;&#10;    private FloorGenerator floorGenerator; // Référence au FloorGenerator&#10;    private static bool timerStarted = false; // Pour éviter les démarrages multiples&#10;&#10;    void Awake()&#10;    {&#10;        controls = new PlayerMove();&#10;        &#10;        // Trouver le FloorGenerator dans la scène&#10;        floorGenerator = FindObjectOfType&lt;FloorGenerator&gt;();&#10;        if (floorGenerator != null)&#10;        {&#10;            floorGenerator.OnPlatformGenerated += PositionPlayerOnPlatform;&#10;        }&#10;    }&#10;&#10;    void OnEnable()&#10;    {&#10;        controls.Enable();&#10;        controls.Player.Move.performed += OnMovePerformed;&#10;        controls.Player.Move.canceled += OnMoveCanceled;&#10;        controls.Player.Jump.performed += OnJumpPerformed;&#10;    }&#10;&#10;    void OnDisable()&#10;    {&#10;        controls.Player.Move.performed -= OnMovePerformed;&#10;        controls.Player.Move.canceled -= OnMoveCanceled;&#10;        controls.Player.Jump.performed -= OnJumpPerformed;&#10;        controls.Disable();&#10;    }&#10;&#10;    private void OnMovePerformed(InputAction.CallbackContext ctx)&#10;    {&#10;        moveInput = ctx.ReadValue&lt;Vector2&gt;();&#10;    }&#10;&#10;    private void OnMoveCanceled(InputAction.CallbackContext ctx)&#10;    {&#10;        moveInput = Vector2.zero;&#10;    }&#10;&#10;    private void OnJumpPerformed(InputAction.CallbackContext ctx)&#10;    {&#10;        Jump();&#10;    }&#10;&#10;    // Start is called before the first frame update&#10;    void Start()&#10;    {&#10;        rb = GetComponent&lt;Rigidbody&gt;();&#10;        animator = GetComponent&lt;Animator&gt;();&#10;        &#10;        // Ne plus appeler PositionPlayerOnGround() car on attend la plateforme&#10;    }&#10;    &#10;    void PositionPlayerOnPlatform(Vector3 platformPosition)&#10;    {&#10;        // Positionner le joueur au centre de la plateforme avec un offset en Y&#10;        Vector3 playerPosition = new Vector3(platformPosition.x, platformPosition.y + 1f, platformPosition.z);&#10;        transform.position = playerPosition;&#10;        &#10;        Debug.Log($&quot;Player positioned on platform at: {playerPosition}&quot;);&#10;    }&#10;&#10;    void PositionPlayerOnGround()&#10;    {&#10;        // Cette méthode n'est plus utilisée mais gardée au cas où&#10;        // Position par défaut plus sûre au centre du monde&#10;        Vector3 defaultPosition = new Vector3(30f, 2f, 30f); // Centre du monde 30x30&#10;        &#10;        // Raycast depuis au-dessus pour trouver la surface du sol&#10;        Vector3 rayStart = defaultPosition + Vector3.up * 10f;&#10;        RaycastHit hit;&#10;        &#10;        // Raycast pour détecter tous les colliders&#10;        if (Physics.Raycast(rayStart, Vector3.down, out hit, 20f))&#10;        {&#10;            // Vérifier si c'est bien un objet au sol&#10;            if (hit.collider.gameObject.name.Contains(&quot;Ground&quot;) ||&#10;                hit.collider.gameObject.name.Contains(&quot;Floor&quot;))&#10;            {&#10;                // Place le joueur sur la surface du sol détectée avec un offset adapté au nouveau système&#10;                Vector3 newPos = hit.point + Vector3.up * 0.0f; // Pas d'offset, directement sur le NavMesh&#10;                transform.position = newPos;&#10;                Debug.Log($&quot;Player positioned on ground surface at: {newPos}&quot;);&#10;            }&#10;            else&#10;            {&#10;                // Position par défaut&#10;                transform.position = defaultPosition;&#10;                Debug.Log(&quot;Player positioned at default location&quot;);&#10;            }&#10;        }&#10;        else&#10;        {&#10;            // Position de secours&#10;            transform.position = defaultPosition;&#10;            Debug.Log(&quot;Could not find ground surface, using default position&quot;);&#10;        }&#10;    }&#10;&#10;    // Update is called once per frame&#10;    void Update()&#10;    {&#10;        // Détection de la marche via l'input&#10;        bool isWalking = moveInput.sqrMagnitude &gt; 0.01f &amp;&amp; isGrounded;&#10;&#10;        // Démarrer le timer dès que le joueur commence à bouger&#10;        if (!timerStarted &amp;&amp; moveInput.sqrMagnitude &gt; 0.01f)&#10;        {&#10;            timerStarted = true;&#10;            Timer timer = FindObjectOfType&lt;Timer&gt;();&#10;            if (timer != null)&#10;            {&#10;                timer.StartTimer();&#10;                Debug.Log(&quot;Premier mouvement détecté - Timer démarré !&quot;);&#10;            }&#10;        }&#10;&#10;        // Gestion des états de saut&#10;        isJumping = !isGrounded &amp;&amp; rb.velocity.y &gt; 0.1f;&#10;        isJumpMiddle = !isGrounded &amp;&amp; Mathf.Abs(rb.velocity.y) &lt;= 0.1f;&#10;        isFalling = !isGrounded &amp;&amp; rb.velocity.y &lt; -0.1f;&#10;&#10;        // Reset explicite si le joueur est au sol et vitesse verticale très faible&#10;        if (isGrounded &amp;&amp; Mathf.Abs(rb.velocity.y) &lt; 0.05f)&#10;        {&#10;            isJumping = false;&#10;            isJumpMiddle = false;&#10;            isFalling = false;&#10;        }&#10;&#10;        if (animator != null)&#10;        {&#10;            animator.SetBool(&quot;isWalking&quot;, isWalking);&#10;            animator.SetBool(&quot;isJumping&quot;, isJumping);&#10;            animator.SetBool(&quot;isJumpMiddle&quot;, isJumpMiddle);&#10;            animator.SetBool(&quot;isFalling&quot;, isFalling);&#10;        }&#10;    }&#10;&#10;    void FixedUpdate()&#10;    {&#10;        // Déplacement relatif à l'orientation du personnage&#10;        Vector3 direction = (transform.right * moveInput.x + transform.forward * moveInput.y).normalized;&#10;        if (direction.sqrMagnitude &gt; 0.01f)&#10;        {&#10;            rb.velocity = new Vector3(direction.x * moveSpeed, rb.velocity.y, direction.z * moveSpeed);&#10;            // Ralentit la rotation du personnage (valeur plus faible)&#10;            float rotationSpeed = 0.02f; // Valeur plus faible pour une rotation plus douce&#10;            Quaternion targetRotation = Quaternion.LookRotation(direction, Vector3.up);&#10;            rb.rotation = Quaternion.Slerp(rb.rotation, targetRotation, rotationSpeed);&#10;        }&#10;        else&#10;        {&#10;            rb.velocity = new Vector3(0, rb.velocity.y, 0);&#10;        }&#10;    }&#10;&#10;    void Jump()&#10;    {&#10;        Debug.Log($&quot;Jump input reçu | isGrounded = {isGrounded}&quot;);&#10;        if (isGrounded)&#10;        {&#10;            rb.AddForce(Vector3.up * jumpForce, ForceMode.Impulse);&#10;            isGrounded = false;&#10;        }&#10;    }&#10;&#10;    void OnCollisionEnter(Collision collision)&#10;    {&#10;        if (collision.contacts[0].normal.y &gt; 0.5f)&#10;        {&#10;            isGrounded = true;&#10;        }&#10;    }&#10;    &#10;    // Méthode pour forcer l'arrêt du joueur à la fin du jeu&#10;    public void ForceStop()&#10;    {&#10;        // Arrête tous les inputs&#10;        moveInput = Vector2.zero;&#10;        &#10;        // Arrête le mouvement du Rigidbody&#10;        if (rb != null)&#10;        {&#10;            rb.velocity = new Vector3(0, rb.velocity.y, 0); // Garde seulement la gravité&#10;        }&#10;        &#10;        // Force l'animation idle&#10;        if (animator != null)&#10;        {&#10;            animator.SetBool(&quot;isWalking&quot;, false);&#10;            animator.SetBool(&quot;isJumping&quot;, false);&#10;            animator.SetBool(&quot;isJumpMiddle&quot;, false);&#10;            animator.SetBool(&quot;isFalling&quot;, false);&#10;        }&#10;        &#10;        Debug.Log(&quot;Player movement stopped - Game Over&quot;);&#10;    }&#10;&#10;    void OnDestroy()&#10;    {&#10;        // Se désabonner de l'événement pour éviter les erreurs&#10;        if (floorGenerator != null)&#10;        {&#10;            floorGenerator.OnPlatformGenerated -= PositionPlayerOnPlatform;&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>