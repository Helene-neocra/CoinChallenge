<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/Assets/Scripts/PlayerController.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/PlayerController.cs" />
              <option name="originalContent" value="using System.Collections;&#10;using System.Collections.Generic;&#10;using UnityEngine;&#10;using UnityEngine.InputSystem;&#10;using UnityEngine.Serialization;&#10;&#10;public class PlayerController : MonoBehaviour&#10;{&#10;    public float moveSpeed = 5f;&#10;    public float jumpForce = 5f;&#10;&#10;    private Vector2 moveInput;&#10;    private Rigidbody rb;&#10;    private PlayerMove controls;&#10;    private bool isGrounded = true;&#10;    private bool isJumping = false;&#10;    private bool isJumpMiddle = false;&#10;    private bool isFalling = false;&#10;    private Animator animator;&#10;    private FloorGenerator floorGenerator; // Référence au FloorGenerator&#10;    public float groundedCast = 0.1f; // Distance du raycast pour détecter le sol&#10;    private static bool timerStarted = false; // Pour éviter les démarrages multiples&#10;&#10;    void Awake()&#10;    {&#10;        controls = new PlayerMove();&#10;        &#10;        // Trouver le FloorGenerator dans la scène&#10;        floorGenerator = FindObjectOfType&lt;FloorGenerator&gt;();&#10;        if (floorGenerator != null)&#10;        {&#10;            floorGenerator.OnPlatformGenerated += PositionPlayerOnPlatform;&#10;        }&#10;    }&#10;&#10;    void OnEnable()&#10;    {&#10;        controls.Enable();&#10;        controls.Player.Move.performed += OnMovePerformed;&#10;        controls.Player.Move.canceled += OnMoveCanceled;&#10;        controls.Player.Jump.performed += OnJumpPerformed;&#10;    }&#10;&#10;    void OnDisable()&#10;    {&#10;        controls.Player.Move.performed -= OnMovePerformed;&#10;        controls.Player.Move.canceled -= OnMoveCanceled;&#10;        controls.Player.Jump.performed -= OnJumpPerformed;&#10;        controls.Disable();&#10;    }&#10;&#10;    private void OnMovePerformed(InputAction.CallbackContext ctx)&#10;    {&#10;        moveInput = ctx.ReadValue&lt;Vector2&gt;();&#10;    }&#10;&#10;    private void OnMoveCanceled(InputAction.CallbackContext ctx)&#10;    {&#10;        moveInput = Vector2.zero;&#10;    }&#10;&#10;    private void OnJumpPerformed(InputAction.CallbackContext ctx)&#10;    {&#10;        Jump();&#10;    }&#10;&#10;    // Start is called before the first frame update&#10;    void Start()&#10;    {&#10;        rb = GetComponent&lt;Rigidbody&gt;();&#10;        animator = GetComponent&lt;Animator&gt;();&#10;        &#10;    }&#10;    &#10;    void PositionPlayerOnPlatform(Vector3 platformPosition)&#10;    {&#10;        // Positionner le joueur au centre de la plateforme avec un offset en Y&#10;        Vector3 playerPosition = new Vector3(platformPosition.x, platformPosition.y + 1f, platformPosition.z);&#10;        transform.position = playerPosition;&#10;        &#10;        Debug.Log($&quot;Player positioned on platform at: {playerPosition}&quot;);&#10;    }&#10;&#10;    // Update is called once per frame&#10;    void Update()&#10;    {&#10;        // Détection de la marche via l'input&#10;        bool isWalking = moveInput.sqrMagnitude &gt; 0.01f &amp;&amp; isGrounded;&#10;&#10;        // Démarrer le timer dès que le joueur commence à bouger&#10;        if (!timerStarted &amp;&amp; moveInput.sqrMagnitude &gt; 0.01f)&#10;        {&#10;            timerStarted = true;&#10;            Timer timer = FindObjectOfType&lt;Timer&gt;();&#10;            if (timer != null)&#10;            {&#10;                timer.StartTimer();&#10;                Debug.Log(&quot;Premier mouvement détecté - Timer démarré !&quot;);&#10;            }&#10;        }&#10;        &#10;        &#10;        // Gestion des états de saut&#10;        isJumping = !isGrounded &amp;&amp; rb.velocity.y &gt; 0.1f;&#10;        isJumpMiddle = !isGrounded &amp;&amp; Mathf.Abs(rb.velocity.y) &lt;= 0.1f;&#10;        isFalling = !isGrounded &amp;&amp; rb.velocity.y &lt; -0.1f;&#10;&#10;        // Reset explicite si le joueur est au sol et vitesse verticale très faible&#10;        if (isGrounded &amp;&amp; Mathf.Abs(rb.velocity.y) &lt; 0.05f)&#10;        {&#10;            isJumping = false;&#10;            isJumpMiddle = false;&#10;            isFalling = false;&#10;        }&#10;&#10;        if (animator != null)&#10;        {&#10;            animator.SetBool(&quot;isWalking&quot;, isWalking);&#10;            animator.SetBool(&quot;isJumping&quot;, isJumping);&#10;            animator.SetBool(&quot;isJumpMiddle&quot;, isJumpMiddle);&#10;            animator.SetBool(&quot;isFalling&quot;, isFalling);&#10;        }&#10;&#10;        if (Physics.Raycast(transform.position, Vector3.down, out var hit, groundedCast))&#10;        {&#10;            // Vérifier si c'est bien un objet au sol&#10;            if (hit.collider.gameObject.CompareTag(&quot;Floor&quot;))&#10;            {&#10;                isGrounded = true;&#10;            }&#10;        }&#10;        else&#10;        {&#10;            isGrounded = false;&#10;        }&#10;    }&#10;&#10;    void FixedUpdate()&#10;    {&#10;        // Déplacement relatif à l'orientation du personnage&#10;        Vector3 direction = (transform.right * moveInput.x + transform.forward * moveInput.y).normalized;&#10;        if (direction.sqrMagnitude &gt; 0.01f)&#10;        {&#10;            rb.velocity = new Vector3(direction.x * moveSpeed, rb.velocity.y, direction.z * moveSpeed);&#10;            // Ralentit la rotation du personnage (valeur plus faible)&#10;            float rotationSpeed = 0.02f; // Valeur plus faible pour une rotation plus douce&#10;            Quaternion targetRotation = Quaternion.LookRotation(direction, Vector3.up);&#10;            rb.rotation = Quaternion.Slerp(rb.rotation, targetRotation, rotationSpeed);&#10;        }&#10;        else&#10;        {&#10;            rb.velocity = new Vector3(0, rb.velocity.y, 0);&#10;        }&#10;    }&#10;&#10;    void Jump()&#10;    {&#10;        Debug.Log($&quot;Jump input reçu | isGrounded = {isGrounded}&quot;);&#10;        if (isGrounded)&#10;        {&#10;            rb.AddForce(Vector3.up * jumpForce, ForceMode.Impulse);&#10;            isGrounded = false;&#10;        }&#10;    }&#10;    &#10;    // Méthode pour forcer l'arrêt du joueur à la fin du jeu&#10;    public void ForceStop()&#10;    {&#10;        // Arrête tous les inputs&#10;        moveInput = Vector2.zero;&#10;        &#10;        // Arrête le mouvement du Rigidbody&#10;        if (rb != null)&#10;        {&#10;            rb.velocity = new Vector3(0, rb.velocity.y, 0); // Garde seulement la gravité&#10;        }&#10;        &#10;        // Force l'animation idle&#10;        if (animator != null)&#10;        {&#10;            animator.SetBool(&quot;isWalking&quot;, false);&#10;            animator.SetBool(&quot;isJumping&quot;, false);&#10;            animator.SetBool(&quot;isJumpMiddle&quot;, false);&#10;            animator.SetBool(&quot;isFalling&quot;, false);&#10;        }&#10;        &#10;        Debug.Log(&quot;Player movement stopped - Game Over&quot;);&#10;    }&#10;&#10;    void OnDestroy()&#10;    {&#10;        // Se désabonner de l'événement pour éviter les erreurs&#10;        if (floorGenerator != null)&#10;        {&#10;            floorGenerator.OnPlatformGenerated -= PositionPlayerOnPlatform;&#10;        }&#10;    }&#10;    &#10;    void OnDrawGizmos()&#10;    {&#10;        // Gizmo pour visualiser le raycast de détection du sol&#10;        Gizmos.color = isGrounded ? Color.green : Color.red;&#10;        Gizmos.DrawLine(transform.position, transform.position + Vector3.down * 1);&#10;        &#10;        Gizmos.color = Color.blue;&#10;        Gizmos.DrawLine(transform.position, transform.position + Vector3.down * groundedCast);&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using System.Collections;&#10;using System.Collections.Generic;&#10;using UnityEngine;&#10;using UnityEngine.InputSystem;&#10;using UnityEngine.Serialization;&#10;&#10;public class PlayerController : MonoBehaviour&#10;{&#10;    public float moveSpeed = 5f;&#10;    public float jumpForce = 5f;&#10;&#10;    private Vector2 moveInput;&#10;    private Rigidbody rb;&#10;    private PlayerMove controls;&#10;    private bool isGrounded = true;&#10;    private bool isJumping = false;&#10;    private bool isJumpMiddle = false;&#10;    private bool isFalling = false;&#10;    private Animator animator;&#10;    private FloorGenerator floorGenerator; // Référence au FloorGenerator&#10;    public float groundedCast = 0.1f; // Distance du raycast pour détecter le sol&#10;    private bool timerStarted = false; // Retirer static pour permettre réinitialisation&#10;&#10;    void Awake()&#10;    {&#10;        controls = new PlayerMove();&#10;        &#10;        // Trouver le FloorGenerator dans la scène&#10;        floorGenerator = FindObjectOfType&lt;FloorGenerator&gt;();&#10;        if (floorGenerator != null)&#10;        {&#10;            floorGenerator.OnPlatformGenerated += PositionPlayerOnPlatform;&#10;        }&#10;    }&#10;&#10;    void OnEnable()&#10;    {&#10;        controls.Enable();&#10;        controls.Player.Move.performed += OnMovePerformed;&#10;        controls.Player.Move.canceled += OnMoveCanceled;&#10;        controls.Player.Jump.performed += OnJumpPerformed;&#10;    }&#10;&#10;    void OnDisable()&#10;    {&#10;        controls.Player.Move.performed -= OnMovePerformed;&#10;        controls.Player.Move.canceled -= OnMoveCanceled;&#10;        controls.Player.Jump.performed -= OnJumpPerformed;&#10;        controls.Disable();&#10;    }&#10;&#10;    private void OnMovePerformed(InputAction.CallbackContext ctx)&#10;    {&#10;        moveInput = ctx.ReadValue&lt;Vector2&gt;();&#10;    }&#10;&#10;    private void OnMoveCanceled(InputAction.CallbackContext ctx)&#10;    {&#10;        moveInput = Vector2.zero;&#10;    }&#10;&#10;    private void OnJumpPerformed(InputAction.CallbackContext ctx)&#10;    {&#10;        Jump();&#10;    }&#10;&#10;    // Start is called before the first frame update&#10;    void Start()&#10;    {&#10;        rb = GetComponent&lt;Rigidbody&gt;();&#10;        animator = GetComponent&lt;Animator&gt;();&#10;        &#10;    }&#10;    &#10;    void PositionPlayerOnPlatform(Vector3 platformPosition)&#10;    {&#10;        // Positionner le joueur au centre de la plateforme avec un offset en Y&#10;        Vector3 playerPosition = new Vector3(platformPosition.x, platformPosition.y + 1f, platformPosition.z);&#10;        transform.position = playerPosition;&#10;        &#10;        Debug.Log($&quot;Player positioned on platform at: {playerPosition}&quot;);&#10;    }&#10;&#10;    // Update is called once per frame&#10;    void Update()&#10;    {&#10;        // Détection de la marche via l'input&#10;        bool isWalking = moveInput.sqrMagnitude &gt; 0.01f &amp;&amp; isGrounded;&#10;&#10;        // Démarrer le timer dès que le joueur commence à bouger&#10;        if (!timerStarted &amp;&amp; moveInput.sqrMagnitude &gt; 0.01f)&#10;        {&#10;            timerStarted = true;&#10;            Timer timer = FindObjectOfType&lt;Timer&gt;();&#10;            if (timer != null)&#10;            {&#10;                timer.StartTimer();&#10;                Debug.Log(&quot;Premier mouvement détecté - Timer démarré !&quot;);&#10;            }&#10;        }&#10;        &#10;        &#10;        // Gestion des états de saut&#10;        isJumping = !isGrounded &amp;&amp; rb.velocity.y &gt; 0.1f;&#10;        isJumpMiddle = !isGrounded &amp;&amp; Mathf.Abs(rb.velocity.y) &lt;= 0.1f;&#10;        isFalling = !isGrounded &amp;&amp; rb.velocity.y &lt; -0.1f;&#10;&#10;        // Reset explicite si le joueur est au sol et vitesse verticale très faible&#10;        if (isGrounded &amp;&amp; Mathf.Abs(rb.velocity.y) &lt; 0.05f)&#10;        {&#10;            isJumping = false;&#10;            isJumpMiddle = false;&#10;            isFalling = false;&#10;        }&#10;&#10;        if (animator != null)&#10;        {&#10;            animator.SetBool(&quot;isWalking&quot;, isWalking);&#10;            animator.SetBool(&quot;isJumping&quot;, isJumping);&#10;            animator.SetBool(&quot;isJumpMiddle&quot;, isJumpMiddle);&#10;            animator.SetBool(&quot;isFalling&quot;, isFalling);&#10;        }&#10;&#10;        if (Physics.Raycast(transform.position, Vector3.down, out var hit, groundedCast))&#10;        {&#10;            // Vérifier si c'est bien un objet au sol&#10;            if (hit.collider.gameObject.CompareTag(&quot;Floor&quot;))&#10;            {&#10;                isGrounded = true;&#10;            }&#10;        }&#10;        else&#10;        {&#10;            isGrounded = false;&#10;        }&#10;    }&#10;&#10;    void FixedUpdate()&#10;    {&#10;        // Déplacement relatif à l'orientation du personnage&#10;        Vector3 direction = (transform.right * moveInput.x + transform.forward * moveInput.y).normalized;&#10;        if (direction.sqrMagnitude &gt; 0.01f)&#10;        {&#10;            rb.velocity = new Vector3(direction.x * moveSpeed, rb.velocity.y, direction.z * moveSpeed);&#10;            // Ralentit la rotation du personnage (valeur plus faible)&#10;            float rotationSpeed = 0.02f; // Valeur plus faible pour une rotation plus douce&#10;            Quaternion targetRotation = Quaternion.LookRotation(direction, Vector3.up);&#10;            rb.rotation = Quaternion.Slerp(rb.rotation, targetRotation, rotationSpeed);&#10;        }&#10;        else&#10;        {&#10;            rb.velocity = new Vector3(0, rb.velocity.y, 0);&#10;        }&#10;    }&#10;&#10;    void Jump()&#10;    {&#10;        Debug.Log($&quot;Jump input reçu | isGrounded = {isGrounded}&quot;);&#10;        if (isGrounded)&#10;        {&#10;            rb.AddForce(Vector3.up * jumpForce, ForceMode.Impulse);&#10;            isGrounded = false;&#10;        }&#10;    }&#10;    &#10;    // Méthode pour forcer l'arrêt du joueur à la fin du jeu&#10;    public void ForceStop()&#10;    {&#10;        // Arrête tous les inputs&#10;        moveInput = Vector2.zero;&#10;        &#10;        // Arrête le mouvement du Rigidbody&#10;        if (rb != null)&#10;        {&#10;            rb.velocity = new Vector3(0, rb.velocity.y, 0); // Garde seulement la gravité&#10;        }&#10;        &#10;        // Force l'animation idle&#10;        if (animator != null)&#10;        {&#10;            animator.SetBool(&quot;isWalking&quot;, false);&#10;            animator.SetBool(&quot;isJumping&quot;, false);&#10;            animator.SetBool(&quot;isJumpMiddle&quot;, false);&#10;            animator.SetBool(&quot;isFalling&quot;, false);&#10;        }&#10;        &#10;        Debug.Log(&quot;Player movement stopped - Game Over&quot;);&#10;    }&#10;&#10;    void OnDestroy()&#10;    {&#10;        // Se désabonner de l'événement pour éviter les erreurs&#10;        if (floorGenerator != null)&#10;        {&#10;            floorGenerator.OnPlatformGenerated -= PositionPlayerOnPlatform;&#10;        }&#10;    }&#10;    &#10;    void OnDrawGizmos()&#10;    {&#10;        // Gizmo pour visualiser le raycast de détection du sol&#10;        Gizmos.color = isGrounded ? Color.green : Color.red;&#10;        Gizmos.DrawLine(transform.position, transform.position + Vector3.down * 1);&#10;        &#10;        Gizmos.color = Color.blue;&#10;        Gizmos.DrawLine(transform.position, transform.position + Vector3.down * groundedCast);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Timer.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Timer.cs" />
              <option name="originalContent" value="using System.Collections;&#10;using System.Collections.Generic;&#10;using UnityEngine;&#10;using UnityEngine.UI;&#10;using TMPro;&#10;&#10;public class Timer : MonoBehaviour&#10;{&#10;    public float gameTime = 60f; // 1 minute en secondes&#10;    public TMP_Text timerText; // Référence au texte UI&#10;    &#10;    private float currentTime;&#10;    private bool isGameRunning = false; // Changé à false pour ne pas démarrer automatiquement&#10;    private bool hasStarted = false; // Nouveau flag pour éviter les démarrages multiples&#10;    &#10;    public delegate void TimeUpDelegate();&#10;    public static event TimeUpDelegate OnTimeUp;&#10;&#10;    // Start is called before the first frame update&#10;    void Start()&#10;    {&#10;        currentTime = gameTime;&#10;        UpdateTimerDisplay();&#10;        &#10;        // S'abonner à l'événement du FloorGenerator pour démarrer le timer&#10;        FloorGenerator floorGen = FindObjectOfType&lt;FloorGenerator&gt;();&#10;        if (floorGen != null)&#10;        {&#10;            floorGen.OnFloorGenerated += OnFloorReady;&#10;        }&#10;    }&#10;    &#10;    void OnFloorReady(float minX, float minZ, float maxX, float maxZ)&#10;    {&#10;        // Le floor est prêt, on peut maintenant détecter quand le joueur y entre&#10;        // Cette méthode sera appelée quand le floor est généré&#10;    }&#10;    &#10;    public void StartTimer()&#10;    {&#10;        if (!hasStarted)&#10;        {&#10;            isGameRunning = true;&#10;            hasStarted = true;&#10;        }&#10;    }&#10;&#10;    // Update is called once per frame&#10;    void Update()&#10;    {&#10;        if (isGameRunning)&#10;        {&#10;            currentTime -= Time.deltaTime;&#10;            &#10;            if (currentTime &lt;= 0)&#10;            {&#10;                currentTime = 0;&#10;                isGameRunning = false;&#10;                OnTimeUp?.Invoke(); // Déclenche l'événement de fin de jeu&#10;            }&#10;            &#10;            UpdateTimerDisplay();&#10;        }&#10;    }&#10;    &#10;    void UpdateTimerDisplay()&#10;    {&#10;        if (timerText != null)&#10;        {&#10;            int minutes = Mathf.FloorToInt(currentTime / 60);&#10;            int seconds = Mathf.FloorToInt(currentTime % 60);&#10;            timerText.text = string.Format(&quot;{0:00}:{1:00}&quot;, minutes, seconds);&#10;        }&#10;    }&#10;    &#10;    public void StopTimer()&#10;    {&#10;        isGameRunning = false;&#10;    }&#10;    &#10;    public bool IsGameRunning()&#10;    {&#10;        return isGameRunning;&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using System.Collections;&#10;using System.Collections.Generic;&#10;using UnityEngine;&#10;using UnityEngine.UI;&#10;using TMPro;&#10;&#10;public class Timer : MonoBehaviour&#10;{&#10;    public float gameTime = 60f; // 1 minute en secondes&#10;    public TMP_Text timerText; // Référence au texte UI&#10;    &#10;    private float currentTime;&#10;    private bool isGameRunning = false; // Changé à false pour ne pas démarrer automatiquement&#10;    private bool hasStarted = false; // Nouveau flag pour éviter les démarrages multiples&#10;    &#10;    public delegate void TimeUpDelegate();&#10;    public static event TimeUpDelegate OnTimeUp;&#10;&#10;    // Start is called before the first frame update&#10;    void Start()&#10;    {&#10;        currentTime = gameTime;&#10;        UpdateTimerDisplay();&#10;        hasStarted = false; // Réinitialiser le flag à chaque nouvelle scène&#10;        &#10;        // S'abonner à l'événement du FloorGenerator pour démarrer le timer&#10;        FloorGenerator floorGen = FindObjectOfType&lt;FloorGenerator&gt;();&#10;        if (floorGen != null)&#10;        {&#10;            floorGen.OnFloorGenerated += OnFloorReady;&#10;        }&#10;    }&#10;    &#10;    void OnFloorReady(float minX, float minZ, float maxX, float maxZ)&#10;    {&#10;        // Le floor est prêt, on peut maintenant détecter quand le joueur y entre&#10;        // Cette méthode sera appelée quand le floor est généré&#10;    }&#10;    &#10;    public void StartTimer()&#10;    {&#10;        if (!hasStarted)&#10;        {&#10;            isGameRunning = true;&#10;            hasStarted = true;&#10;        }&#10;    }&#10;&#10;    // Update is called once per frame&#10;    void Update()&#10;    {&#10;        if (isGameRunning)&#10;        {&#10;            currentTime -= Time.deltaTime;&#10;            &#10;            if (currentTime &lt;= 0)&#10;            {&#10;                currentTime = 0;&#10;                isGameRunning = false;&#10;                OnTimeUp?.Invoke(); // Déclenche l'événement de fin de jeu&#10;            }&#10;            &#10;            UpdateTimerDisplay();&#10;        }&#10;    }&#10;    &#10;    void UpdateTimerDisplay()&#10;    {&#10;        if (timerText != null)&#10;        {&#10;            int minutes = Mathf.FloorToInt(currentTime / 60);&#10;            int seconds = Mathf.FloorToInt(currentTime % 60);&#10;            timerText.text = string.Format(&quot;{0:00}:{1:00}&quot;, minutes, seconds);&#10;        }&#10;    }&#10;    &#10;    public void StopTimer()&#10;    {&#10;        isGameRunning = false;&#10;    }&#10;    &#10;    public bool IsGameRunning()&#10;    {&#10;        return isGameRunning;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>